#!/usr/bin/env python

"""
CISM namelist creator
"""
import sys, os

_CIMEROOT = os.environ.get("CIMEROOT")
if _CIMEROOT is None:
    raise SystemExit("ERROR: must set CIMEROOT environment variable")

_LIBDIR = os.path.join(_CIMEROOT, "scripts", "Tools")
sys.path.append(_LIBDIR)

from standard_script_setup import *
from CIME.buildnml import create_namelist_infile, parse_input
from CIME.case import Case
from CIME.utils import expect, safe_copy
from CIME.nmlgen import NamelistGenerator

_final_template = """########################################
# I/O configuration follows
########################################

[CF default]
title: CISM simulation
institution: Community Earth System Model

[CF input]
name: {filename}"""

logger = logging.getLogger(__name__)

#----------------------------------------------------
# Set some important constants, such as important
# values of certain config file parameters
#----------------------------------------------------
# value of 'sigma' that signifies that values are read from a sigma section
_SIGMA_IN_CONFIG_FILE = 2

# value of 'gthf' signifying that we should calculate gthf, and thus
# we should have a 'gthf' section
_GTHF_CALCULATE = 2

# value of 'isostasy' signifying that isostasy is enabled, and thus we
# should have an 'isostasy' section
_ISOSTASY_ON = 1

# pylint: disable=too-many-arguments,too-many-locals,too-many-branches,too-many-statements
####################################################################################
def _create_namelist(case, confdir, inst_string, infile, nmlgen, data_list_path):
####################################################################################
    """Write out the namelist for this component.

    Most arguments are the same as those for `NamelistGenerator`. The
    `inst_string` argument is used as a suffix to distinguish files for
    different instances. The `confdir` argument is used to specify the directory
    in which output files will be placed.
    """
    #----------------------------------------------------
    # Create config dictionary
    #----------------------------------------------------
    config = {}
    config['lnd_grid']  = case.get_value("LND_GRID")
    config['glc_grid']  = case.get_value("GLC_GRID")
    config['cism_phys'] = case.get_value("CISM_PHYS")
    config['cism_evolve'] = '.true.' if case.get_value('CISM_EVOLVE') else '.false.'
    config['glc_two_way_coupling'] = '.true.' if case.get_value('GLC_TWO_WAY_COUPLING') else '.false.'
    config['ncpl_base_period'] = case.get_value("NCPL_BASE_PERIOD")
    config['calendar'] = case.get_value("CALENDAR")

    run_type = case.get_value("RUN_TYPE")
    cism_observed_ic = case.get_value("CISM_OBSERVED_IC")
    comp_interface = case.get_value("COMP_INTERFACE")

    #----------------------------------------------------
    # Initialize namelist defaults
    #----------------------------------------------------
    nmlgen.init_defaults(infile, config,
                         skip_default_for_groups=["glc_override_nml",
                                                  "gthf",
                                                  "isostasy",
                                                  "sigma"])

    #----------------------------------------------------
    # Set values not obtained in the default settings
    #----------------------------------------------------

    # NOTE: with the nuopc interface, the CISM run phase is never called when running
    # in noevolve mode, so a restart file will never be written for cism - only initial
    # information will be sent back to CTSM.
    if (comp_interface == 'nuopc' and config['cism_evolve'] == 'FALSE'):
        logger.info("Interface is nuopc, cism is not evolving: CISM run_type is always startup")
        run_type = "startup"

    nmlgen.add_default("paramfile", value="cism.config"+inst_string, ignore_abs_path=True)

    if run_type == 'startup':
        nmlgen.add_default('restart',value=0)
    elif cism_observed_ic == 'TRUE':
        if run_type == 'branch':
            expect(False,"CISM_OBSERVED_IC=TRUE not allowed for branch runs - only for hybrid runs")
        else:
            nmlgen.add_default('restart', value=0)
    elif run_type == 'hybrid' and config['cism_evolve'] == 'FALSE':
        # We could use the hybrid refcase's CISM restart file in this case. However, we
        # often run into problems where a change in CISM makes it incompatible with old
        # restart files, and this breaks configurations that are set up as hybrid runs
        # (typically B and F compsets). Those hybrid cases typically use NOEVOLVE (i.e.,
        # CISM_EVOLVE=FALSE), where the restart file really doesn't matter. So, rather
        # than requiring ourselves to recreate all of those refcases whenever we break
        # compatibility with old restart files, an easier-to-maintain solution is to just
        # use observed initial conditions rather than the restart file whenever we're
        # running a hybrid case with CISM_EVOLVE=FALSE.
        #
        # One theoretical problem with this is: If someone did a run with
        # CISM_EVOLVE=TRUE, then did a hybrid case off of that with CISM_EVOLVE=FALSE,
        # hoping that this would keep the ice sheet fixed at the previously-spun-up state,
        # they wouldn't get what they want: instead the ice sheet would be reset to
        # observed initial conditions. Thus, the user would need to explicitly set
        # 'cisminputfile' and 'restart' in this case.
        nmlgen.add_default('restart', value=0)
    elif run_type == 'branch' or run_type == 'hybrid':
        run_refcase = case.get_value('RUN_REFCASE')
        run_refdate = case.get_value('RUN_REFDATE')
        rundir = case.get_value('RUNDIR')
        filename = "{refcase}.cism{inst_string}.r.{refdate}-00000.nc".format(
            refcase=run_refcase, inst_string=inst_string, refdate=run_refdate)
        if not os.path.exists(os.path.join(rundir, filename)):
            # If the version with INST_STRING doesn't exist, try without INST_STRING. This
            # is needed when starting a multi-instance case from a single-instance
            # refcase.
            filename = "{refcase}.cism.r.{refdate}-00000.nc".format(
                refcase=run_refcase, refdate=run_refdate)

        nmlgen.add_default('cisminputfile', filename, ignore_abs_path=True)
        nmlgen.add_default('restart', value=1)
    else:
        expect(False, "Unknown RUN_TYPE: {} ".format(run_type))

    startdate = case.get_value("RUN_STARTDATE")
    if run_type == 'branch':
        startdate = case.get_value("RUN_REFDATE")
    date_array = startdate.split('-')
    nmlgen.add_default("iyear0"  , value=int(date_array[0]))
    nmlgen.add_default("imonth0" , value=int(date_array[1]))
    nmlgen.add_default("iday0"   , value=int(date_array[2]))
    nmlgen.add_default("ihour0"  , value=0)
    nmlgen.add_default("iminute0", value=0)
    nmlgen.add_default("isecond0", value=0)

    _set_glc_dt(nmlgen,
                ncpl_base_period=config["ncpl_base_period"],
                glc_ncpl=case.get_value("GLC_NCPL"))

    #----------------------------------------------------
    # cism_in: Set values for sections that are added conditionally and write file
    #----------------------------------------------------

    if nmlgen.get_value("enable_frac_overrides") == ".true.":
        nmlgen.add_defaults_for_group("glc_override_nml")
    else:
        nmlgen.confirm_group_is_empty(
            "glc_override_nml",
            "items in glc_override_nml can only be set if enable_frac_overrides is set to .true.")

    groups = ["cism_params","cism_history","time_manager_nml", "glc_override_nml"]
    output_file = os.path.join(confdir, "cism_in")
    nmlgen.write_output_file(output_file, data_list_path, groups=groups, sorted_groups=False)

    #----------------------------------------------------
    # cism.config: Set values for sections that are added conditionally and write file
    #----------------------------------------------------
    output_file = os.path.join(confdir, "cism.config")
    _update_cism_config(nmlgen, output_file, mode="w", header="grid", group="grid")
    _update_cism_config(nmlgen, output_file, mode="a", header="GLAD climate", group="glad_climate")
    _update_cism_config(nmlgen, output_file, mode="a", header="options", group="options")
    _add_conditional_section_to_cism_config(nmlgen, output_file, group="sigma",
                                            control_var="sigma",
                                            value_for_addition=_SIGMA_IN_CONFIG_FILE)
    _update_cism_config(nmlgen, output_file, mode="a", header="time", group="time")
    _update_cism_config(nmlgen, output_file, mode="a", header="parameters", group="parameters")
    _update_cism_config(nmlgen, output_file, mode="a", header="ho_options", group="ho_options")
    _add_conditional_section_to_cism_config(nmlgen, output_file, group="gthf",
                                            control_var="gthf",
                                            value_for_addition=_GTHF_CALCULATE)
    _add_conditional_section_to_cism_config(nmlgen, output_file, group="isostasy",
                                            control_var="isostasy",
                                            value_for_addition=_ISOSTASY_ON)

    final_text = _final_template.format(filename=nmlgen.get_value('cisminputfile'))
    with open(output_file, "a") as file_obj:
        file_obj.write("{}\n".format(final_text))

###############################################################################
def _initial_consistency_checks(config):
###############################################################################
    if config["calendar"] != "NO_LEAP":
        # See https://github.com/ESCOMP/CISM-wrapper/issues/1
        errmsg = """\
CISM currently only supports a NO_LEAP calendar.
Either change the calendar to NO_LEAP or create a case without CISM.
(For the latter, you can use SGLC in place of CISM if you don't care about ice evolution.
Besides not getting CISM diagnostics, this will just result in slightly different glacier
cover in CLM.)"""
        print(errmsg)
        expect(False, "CISM currently only supports a NO_LEAP calendar")

###############################################################################
def _set_glc_dt(nmlgen, ncpl_base_period, glc_ncpl):
    """
    Sets dt-related values in cism_in (NOT the values in cism.config)
    """
    # The logic here assumes that we want one timestep per coupling interval
    if ncpl_base_period == 'hour':
        if 3600 % glc_ncpl != 0:
            expect(False, "glc_ncpl {} doesn't divide an hour evenly".format(glc_ncpl))
        dt_option = "seconds"
        dt_count = 3600 / glc_ncpl
    elif ncpl_base_period == 'day':
        dt_option = "steps_per_day"
        dt_count = glc_ncpl
    elif ncpl_base_period == 'year':
        dt_option = "steps_per_year"
        dt_count = glc_ncpl
    elif ncpl_base_period == 'decade':
        dt_option = "steps_per_year"
        dt_count = glc_ncpl / 10
    else:
        expect(False, "invalid NCPL_BASE_PERIOD {}".format(ncpl_base_period))

    nmlgen.add_default("dt_option", value=dt_option)
    nmlgen.add_default("dt_count", value=dt_count)

###############################################################################
def _update_cism_config(nmlgen, output_file, mode, header, group):
###############################################################################
    """Append an entry to the cism.config file"""
    with open(output_file, mode) as file_obj:
        file_obj.write("[{}]\n".format(header))
    nmlgen.add_nmlcontents(output_file, group=group, sorted_groups=False)

###############################################################################
def _add_conditional_section_to_cism_config(nmlgen, output_file, group,
                                            control_var, value_for_addition):
    """Add a section to the cism.config file conditionally

    Args:
    nmlgen: the nmlgen object
    output_file: path to output file
    group: name of group to add conditionally; assumed to be the same as the header for
           the section
    control_var: name of variable in nmlgen that controls whether to add this section
    value_for_addition: int - add the section if control_var is equal to this value
    """
    if int(nmlgen.get_value(control_var)) == value_for_addition:
        nmlgen.add_defaults_for_group(group)
        _update_cism_config(nmlgen, output_file, mode="a", header=group, group=group)
    else:
        errmsg = "items in {} section can only be set if {} is set to {}".format(
            group, control_var, value_for_addition)
        nmlgen.confirm_group_is_empty(group, errmsg)

###############################################################################
def buildnml(case, caseroot, compname):
###############################################################################
    """Build the cism namelist """

    # Build the component namelist
    if compname != "cism":
        raise AttributeError

    lnd_grid = case.get_value("LND_GRID")
    glc_grid = case.get_value("GLC_GRID")
    cism_phys = case.get_value("CISM_PHYS")
    cimeroot = case.get_value("CIMEROOT")
    glcroot = case.get_value("COMP_ROOT_DIR_GLC")
    ninst = case.get_value("NINST_GLC")
    rundir = case.get_value("RUNDIR")

    # Determine configuration directory
    confdir = os.path.join(caseroot, "Buildconf", "cismconf")
    if not os.path.isdir(confdir):
        os.makedirs(confdir)

    # Clear out old data
    data_list_path = os.path.join(caseroot,"Buildconf","cism.input_data_list")
    if os.path.exists(data_list_path):
        os.remove(data_list_path)

    #----------------------------------------------------
    # Construct the namelist generator
    #----------------------------------------------------
    # determine directory for user modified namelist_definitions.xml and namelist_defaults.xml
    user_xml_dir = os.path.join(caseroot, "SourceMods", "src.cism")
    expect (os.path.isdir(user_xml_dir),
            "user_xml_dir {} does not exist ".format(user_xml_dir))

    # NOTE: User definition *replaces* existing definition.
    namelist_xml_dir = os.path.join(glcroot, "cime_config")
    definition_file = [os.path.join(namelist_xml_dir, "namelist_definition_cism.xml")]
    user_definition = os.path.join(user_xml_dir, "namelist_definition_cism.xml")
    if os.path.isfile(user_definition):
        definition_file = [user_definition]
    for file_ in definition_file:
        expect(os.path.isfile(file_), "Namelist XML file {} not found!".format(file_))

    # Create the namelist generator object - independent of instance
    nmlgen = NamelistGenerator(case, definition_file)

    #----------------------------------------------------
    # Loop over instances
    #----------------------------------------------------
    for inst_counter in range(1, ninst+1):
        # determine instance string
        inst_string = ""
        if ninst > 1:
            inst_string = '_' + '{:04d}'.format(inst_counter)

        # If multi-instance case does not have restart file, use
        # single-case restart for each instance
        rpointer = "rpointer.glc"
        if (os.path.isfile(os.path.join(rundir,rpointer)) and
            (not os.path.isfile(os.path.join(rundir,rpointer + inst_string)))):
            safe_copy(os.path.join(rundir, rpointer),
                      os.path.join(rundir, rpointer + inst_string))

        user_nl_file = os.path.join(caseroot, "user_nl_cism" + inst_string)
        expect(os.path.isfile(user_nl_file),
               "Missing required user_nl_file {}".format(user_nl_file))
        infile = os.path.join(confdir, "namelist")
        create_namelist_infile(case, user_nl_file, infile)
        namelist_infile = [infile]

        # create namelist
        _create_namelist(case, confdir, inst_string, namelist_infile, nmlgen, data_list_path)

        # -----------------------------------------------------
        # copy resolved namelist to rundir
        # -----------------------------------------------------

        if os.path.isdir(rundir):
            file_src = os.path.join(confdir, "cism_in")
            file_dest = os.path.join(rundir, "cism_in")
            if ninst > 1:
                file_dest += inst_string
            logger.debug("CISM namelist copy: file_src {} file_dest {} ".format(file_src, file_dest))
            safe_copy(file_src,file_dest)

            file_src = os.path.join(confdir, "cism.config")
            file_dest = os.path.join(rundir, "cism.config")
            if ninst > 1:
                file_dest += inst_string
            logger.debug("CISM namelist copy: file_src {} file_dest {} ".format(file_src, file_dest))
            safe_copy(file_src,file_dest)

###############################################################################
def _main_func():

    caseroot = parse_input(sys.argv)
    with Case(caseroot) as case:
        buildnml(case, caseroot, "cism")

if __name__ == "__main__":
    _main_func()
